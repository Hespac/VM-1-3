#include "pch.h"

void dichotomy(char* s, double a, double b, double eps)//метод дихотомии
{
	cout << "Выбран метод дихотомии" << endl;

	double c = 0; //средняя точка
	double ex = 0;//погрешность 

	do
	{
		c = (a + b) / 2; //	нахождение средней точки в интервале (a, b)

		if ((f(a, 0) * f(c, 0)) <= 0)// если меньше или равно 0, то движемся влево
		{
			b = c;
		}
		else //иначе движемся вправо
		{
			a = c;
		}

		ex = (b - a) / 2;//нахождение погрешности определения корня
	}
	while ((ex) >= eps || fabs(f(c, 0)) >= eps);//метод выполняется пока не достигнет необходимой точности

	cout << "Ответ: " << c << endl;//вывод вычисленного корня 
	record(c, ex, eps, s); //записывание в файл
}

void mhord(char* s, double a, double b, double eps)//метод хорд
{
	cout << "Выбран метод хорд" << endl;

	double c = 0;//точка пересечения хорды с осью абсцисс
	double x = 0;//новое приблежение корня 
	double ex = 0;

	do
	{
		c = a - (f(a, 0) / (f(b, 0) - f(a, 0))) * (b - a);//нахождение точки пересечения хорды с осью абсцисс
		//нахождение значение функции f(x) в точках a,b и с
		if (f(a, 0) * f(c, 0) <= 0)//если выполняется условие, то корень находится внутри левого отрезка
		{
			x = b;
			b = c;
		}
		else//корень находится правого отрезка
		{
			x = a;
			a = c;
		}

		ex = fabs(c - x);//разность двух последовательных приближений
	} while (ex >= eps || fabs(f(c, 0)) >= eps);//метод выполняется пока не достигнет необходимой точности

	cout << "Ответ: " << c << endl;//вывод вычисленного корня
	record(c, ex, eps, s);//записывание в файл
}

void newton(char* s, double a, double b, double eps)//метод ньютона
{
	cout << "Выбран метод Ньютона" << endl;

	double c = (f(a, 0) * f(a, 2) > 0) ? a : b;//проверяется границы интервала 
	double ex = 0;

	do
	{
		double x = c;//значение предсподнего приблежение корня
		c = x - (f(x, 0) / f(x, 1));//Функция для метода Ньютона

		ex = fabs(c - x);//разность двух последовательных приближений
	} while (ex >= eps || fabs(f(c, 0)) >= eps);//метод выполняется пока не достигнет необходимой точности

	cout << "Ответ: " << c << endl;//вывод вычисленного корня
	record(c, ex, eps, s);//записывание в файл
}

void mcombined(char* s, double a, double b, double eps)//комбинированный метод
{
	cout << "Выбран комбинированный метод" << endl;

	double c = 0;
	double ex = 0;
	double result = 0;

	do
	{
		c = a - f(a, 0) * (b - a) / (f(b, 0) - f(a, 0));//нахождение точки пересечения хорды с осью абсцисс
		//проверяются границы интервала
		if ((f(a, 0) * f(a, 2)) > 0)//если выполняется условие, то точка a перемешается ближе к корню по формуле Ньютона, а точка b по формуле методу хорд
		{
			a = a - f(a, 0) / f(a, 1);
			b = c;
		}
		else// a распологается по методу Хорд, а b по формуле Ньютона
		{
			a = c;
			b = b - f(b, 0) / f(b, 1);
		}

		result = (a + b) / 2;//точка приблежения корня
		ex = fabs(f(result, 0));//нахождение погрешности определения корня
	} while ((ex >= eps) || (abs(b - a) / 2 >= eps));//метод выполняется пока не достигнет необходимой точности

	record(result, ex, eps, s);//записывание в файл
	cout << "Ответ: " << result << endl;//вывод вычисленного корня
}

void miteration(char* s, double a, double b, double eps)//метод итераций
{
	cout << "Выбран итерационный метод" << endl;

	double del = 0;
	//проверяются границы интервала
	double x0 = (f(a, 2) != ERR_UNKNOWN_DER)
		? ((f(a, 0) * f(a, 2) > 0) ? a : b)
		: (f(a, 0) * f(a - f(a, 0) * (b - a) / (f(b, 0) - f(a, 0)), 0) <= 0) ? a : b;

	do
	{
		double x = x0 - f(x0, 0) / f(x0, 1);//функия для итерационного метода
		del = fabs(x - x0);//разность двух последовательных приближений
		x0 = x;
	} while ((del >= eps) || (f(x0, 0) >= eps));//метод выполняется пока не достигнет необходимой точности

	record(x0, del, eps, s);//записывание в файл
	cout << "Ответ: " << x0 << endl;//вывод вычисленного корня
}

void mgoldSec(char* s, double a, double b, double eps)//метод золотого сечения
{
	cout << "Выбран метод золотого сечения" << endl;

	double c = 0;
	double ex = 0;

	do
	{
		//разбиение интервала двумя симметричными относильно границы интервала точками
		double x1 = b - (b - a) / ((1 + sqrt(5)) / 2);
		double x2 = a + (b - a) / ((1 + sqrt(5)) / 2);

		if (f(a, 0) * f(x2, 0) <= 0)//проверка какому из интервалов принадлежит корень
		{
			b = x2;
		}
		else
		{
			a = x1;
		}

		ex = fabs(b - a) / 2;
		c = (a + b) / 2;//новое приблежение корня
	} while ((ex >= eps) || (fabs(f(c, 0)) >= eps));//метод выполняется пока не достигнет необходимой точности

	cout << "Ответ: " << c << endl;//вывод вычисленного корня
	record(c, ex, eps, s);//записывание в файл
}
